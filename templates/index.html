<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Algorithm Visualizer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --info-color: #1abc9c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        nav {
            background-color: var(--dark-color);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        nav ul {
            display: flex;
            list-style: none;
            justify-content: center;
            flex-wrap: wrap;
        }

        nav li {
            margin: 0;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 1rem 1.5rem;
            display: block;
            transition: all 0.3s ease;
            font-weight: 500;
            border-bottom: 3px solid transparent;
        }

        nav a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-bottom-color: var(--accent-color);
        }

        nav a.active {
            background-color: rgba(255, 255, 255, 0.2);
            border-bottom-color: var(--accent-color);
        }

        nav i {
            margin-right: 8px;
        }

        main {
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }

        section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        section.active-section {
            display: block;
        }

        h2 {
            color: var(--dark-color);
            margin-bottom: 1.5rem;
            font-size: 2rem;
            position: relative;
            padding-bottom: 10px;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 3px;
            background-color: var(--primary-color);
        }

        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .card i {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .card h3 {
            margin-bottom: 0.5rem;
            color: var(--dark-color);
        }

        .card p {
            color: #666;
            font-size: 0.9rem;
        }

        .algorithm-controls {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        .algorithm-controls select, 
        .algorithm-controls input {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .algorithm-controls button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
        }

        .algorithm-controls button:hover {
            background-color: var(--secondary-color);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .input-group label {
            font-weight: 500;
        }

        .hidden {
            display: none;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            background: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 500;
        }

        tr:hover {
            background-color: #f5f5f5;
        }

        .visualization {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #gantt-chart {
            display: flex;
            height: 60px;
            margin: 1rem 0;
            background-color: #f9f9f9;
            border-radius: 4px;
            overflow: hidden;
        }

        .gantt-block {
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            height: 100%;
            border-right: 1px solid white;
        }

        footer {
            background-color: var(--dark-color);
            color: white;
            text-align: center;
            padding: 1.5rem 0;
            margin-top: 2rem;
        }

        .btn-launch {
            background-color: var(--success-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease;
            margin: 1rem 0;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-launch:hover {
            background-color: #27ae60;
        }

        .btn-launch i {
            font-size: 1rem;
        }



        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            nav ul {
                flex-direction: column;
                align-items: center;
            }

            nav a {
                padding: 0.75rem 1rem;
            }

            .cards {
                grid-template-columns: 1fr;
            }

            .algorithm-controls {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>OS Algorithm Visualizer</h1>
            <p>Learn operating system concepts through interactive visualizations</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="#" class="active" data-section="home"><i class="fas fa-home"></i> Home</a></li>
                <li><a href="#" data-section="cpu"><i class="fas fa-microchip"></i> CPU Scheduling</a></li>
                <li><a href="#" data-section="memory"><i class="fas fa-memory"></i> Memory Management</a></li>
                <li><a href="#" data-section="disk"><i class="fas fa-hdd"></i> Disk Scheduling</a></li>
                <li><a href="#" data-section="page"><i class="fas fa-file-alt"></i> Page Replacement</a></li>
                <li><a href="#" data-section="os"><i class="fas fa-laptop-code"></i> OS Concepts</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <!-- Home Section -->
        <section id="home-section" class="active-section">
            <h2>Welcome to OS Algorithm Visualizer</h2>
            <p>This interactive tool helps you understand complex operating system algorithms through visualizations and simulations. Click on any of the cards below to explore different OS concepts.</p>
            
            <div class="cards">
                <div class="card" data-section="cpu">
                    <i class="fas fa-microchip"></i>
                    <h3>CPU Scheduling</h3>
                    <p>Visualize FCFS, SJF, Priority, Round Robin algorithms</p>
                </div>
                
                <div class="card" data-section="memory">
                    <i class="fas fa-memory"></i>
                    <h3>Memory Management</h3>
                    <p>Explore First Fit, Best Fit, Worst Fit allocation</p>
                </div>
                
                <div class="card" data-section="disk">
                    <i class="fas fa-hdd"></i>
                    <h3>Disk Scheduling</h3>
                    <p>Understand FCFS, SSTF, SCAN, C-SCAN, LOOK</p>
                </div>
                
                <div class="card" data-section="page">
                    <i class="fas fa-file-alt"></i>
                    <h3>Page Replacement</h3>
                    <p>Learn FIFO, LRU, Optimal algorithms</p>
                </div>

                <div class="card" data-section="os">
                    <i class="fas fa-laptop-code"></i>
                    <h3>OS Concepts</h3>
                    <p>Explore fundamental operating system concepts</p>
                </div>
            </div>

            <div style="margin-top: 2rem; text-align: center;">
                <h3>Ready to explore?</h3>
                <p>Select a category from the menu or click on any card above to get started.</p>
            </div>
        </section>

        <!-- CPU Scheduling Section -->

        <section id="cpu-section" style="font-family: 'Inter', sans-serif;">
            <h2 style="font-size: 28px; color: #154360;">CPU Scheduling Algorithm Visualizer</h2>
            <p style="color: #333;">Explore how CPU scheduling algorithms operate through intuitive descriptions, use cases, and Python logic examples.</p>

            <div class="algorithm-controls" style="margin: 20px 0;">
                <select id="cpu-algo-select" onchange="showCpuAlgo(); toggleQuantum()" style="padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #aaa;">
                    <option value="fcfs">First Come First Served (FCFS)</option>
                    <option value="sjf">Shortest Job First (SJF)</option>
                    <option value="priority-pre">Priority Scheduling (Preemptive)</option>
                    <option value="priority-non">Priority Scheduling (Non-Preemptive)</option>
                    <option value="multi">Multilevel Queue</option>
                    <option value="feedback">Multilevel Feedback Queue</option>
                    <option value="rr">Round Robin</option>
                </select>



                <button onclick="launchCPUScheduling()">Launch Visualizer</button>

                <script>
                function launchCPUScheduling() {
                    fetch('/cpu_scheduling')
                        .then(() => alert('Visualizer launched!'))
                        .catch(() => alert('Launch failed'));
                }
                </script>

            </div>
            <script>
                    function showCpuAlgo() {
                        const selected = document.getElementById('cpu-algo-select').value;
                        const ids = ['fcfs', 'sjf', 'priority-pre', 'priority-non', 'multi','feedback','rr'];

                        ids.forEach(id => {
                        const section = document.getElementById(id);
                        if (section) {
                            section.style.display = (id == selected) ? 'block' : 'none';
                        }
                        });
                    }
            </script>

            <!-- CPU Card Style -->
            <style>
                .cpu-algo-card {
                    display: none;
                    background: #f4f9fd;
                    border-left: 6px solid #28b463;
                    padding: 24px;
                    border-radius: 12px;
                    margin-top: 20px;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.05);
                }

                .cpu-algo-card h3 {
                    margin-top: 0;
                    color: #1d8348;
                    font-size: 22px;
                }

                .cpu-algo-card ul {
                    padding-left: 18px;
                }

                pre {
                    background-color: #eaf3fb;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 14px;
                    overflow-x: auto;
                }

                code {
                    font-family: 'Courier New', monospace;
                    color: #1B4F72;
                }
            </style>

            <!-- FCFS -->
            <div class="cpu-algo-card" id="fcfs" style="display: block;">
                <h3>First Come First Served (FCFS)</h3>
                <p>Processes are scheduled in the order they arrive. It’s simple and non-preemptive.</p>
                <ul>
                    <li><strong>Good for:</strong> Simple batch systems</li>
                    <li><strong>Bad for:</strong> Minimizing wait time</li>
                </ul>
                <p><strong>Example:</strong> Processes with arrival times and burst times: P1(0,4), P2(1,3), P3(2,1)</p>
                <h4>Algorithm (Python)</h4>
                <pre><code>def fcfs(processes):
            processes.sort(key=lambda x: x['arrival'])
            time = 0
            for p in processes:
                if time < p['arrival']:
                    time = p['arrival']
                p['start'] = time
                time += p['burst']
                p['completion'] = time
            return processes</code></pre>
            </div>

            <!-- SJF -->
            <div class="cpu-algo-card" id="sjf">
                <h3>Shortest Job First (SJF)</h3>
                <p>Executes the process with the smallest burst time next. Can be preemptive or non-preemptive.</p>
                <ul>
                    <li><strong>Good for:</strong> Reducing average waiting time</li>
                    <li><strong>Bad for:</strong> Starvation of long jobs</li>
                </ul>
                <p><strong>Example:</strong> Processes with burst times: P1(6), P2(2), P3(8), P4(3)</p>
                <h4>Algorithm (Non-preemptive, Python)</h4>
                <pre><code>def sjf(processes):
            time = 0
            completed = []
            while processes:
                available = [p for p in processes if p['arrival'] <= time]
                if not available:
                    time += 1
                    continue
                shortest = min(available, key=lambda x: x['burst'])
                processes.remove(shortest)
                shortest['start'] = time
                time += shortest['burst']
                shortest['completion'] = time
                completed.append(shortest)
            return completed</code></pre>
            </div>

            <!-- Priority Preemptive -->
            <div class="cpu-algo-card" id="priority-pre">
                <h3>Priority Scheduling (Preemptive)</h3>
                <p>Runs the highest priority process available. Can switch mid-process.</p>
                <ul>
                    <li><strong>Good for:</strong> Responsive to urgent tasks</li>
                    <li><strong>Bad for:</strong> Starvation of lower-priority tasks</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code># Example logic with preemption
        # Not full implementation
        def priority_preemptive(processes):
            # Logic involves checking and updating queue each time unit
            pass</code></pre>
            </div>

            <!-- Priority Non-Preemptive -->
            <div class="cpu-algo-card" id="priority-non">
                <h3>Priority Scheduling (Non-Preemptive)</h3>
                <p>Once a process starts, it completes even if a higher priority arrives.</p>
                <ul>
                    <li><strong>Good for:</strong> Simplicity, control</li>
                    <li><strong>Bad for:</strong> Long wait for high-priority jobs</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code>def priority_non_preemptive(processes):
            processes.sort(key=lambda x: (x['arrival'], x['priority']))
            # Similar logic to FCFS but with priority-based sorting
            pass</code></pre>
            </div>

            <!-- Multilevel Queue -->
            <div class="cpu-algo-card" id="multi">
                <h3>Multilevel Queue Scheduling</h3>
                <p>Processes are permanently assigned to a queue based on type. Each queue has its own scheduling policy.</p>
                <ul>
                    <li><strong>Good for:</strong> System with distinct process types</li>
                    <li><strong>Bad for:</strong> Inflexibility</li>
                </ul>
                <h4>Conceptual Python Structure</h4>
                <pre><code>queues = {
            "foreground": [ ... ],
            "background": [ ... ]
        }
        # Foreground: RR, Background: FCFS</code></pre>
            </div>

            <!-- Multilevel Feedback Queue -->
            <div class="cpu-algo-card" id="feedback">
                <h3>Multilevel Feedback Queue</h3>
                <p>Processes can move between queues based on behavior. Prevents starvation.</p>
                <ul>
                    <li><strong>Good for:</strong> Adaptive systems</li>
                    <li><strong>Bad for:</strong> Complex to implement</li>
                </ul>
                <h4>Basic Idea</h4>
                <pre><code># Queue levels with decreasing priority
        # Promote or demote processes based on usage
        # Example only; full code is complex</code></pre>
            </div>

            <!-- Round Robin -->
            <div class="cpu-algo-card" id="rr">
                <h3>Round Robin (RR)</h3>
                <p>Each process gets a fixed time quantum in cyclic order. Fair and responsive.</p>
                <ul>
                    <li><strong>Good for:</strong> Time-sharing systems</li>
                    <li><strong>Bad for:</strong> High context switch overhead</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code>def round_robin(processes, quantum):
            queue = processes[:]
            time = 0
            while queue:
                process = queue.pop(0)
                if process['remaining'] > quantum:
                    process['remaining'] -= quantum
                    time += quantum
                    queue.append(process)
                else:
                    time += process['remaining']
                    process['completion'] = time
            return processes</code></pre>
            </div>
        </section>

<!-- CPU Scheduling Section -->


        <!-- Memory Management Section -->
        <section id="memory-section" style="font-family: 'Inter', sans-serif;">
            <h2 style="font-size: 28px; color: #154360;">Memory Management Algorithms</h2>
            <p style="color: #333;">Memory management handles the allocation and deallocation of memory blocks to processes during execution to optimize system performance and avoid fragmentation.</p>

            <div class="algorithm-controls" style="margin: 20px 0;">
                <select id="memory-algo-select" onchange="showMemoryAlgo()" style="padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #aaa;">
                    <option value="firstfit">First Fit</option>
                    <option value="bestfit">Best Fit</option>
                    <option value="worstfit">Worst Fit</option>
                    <option value="segmentation">Segmentation</option>
                    <option value="paging">Paging</option>
                </select>

                <button onclick="launchMenmoryManagement()">Launch Visualizer</button>

                <script>
                function launchMenmoryManagement() {
                    fetch('/memory_management')
                        .then(() => alert('Visualizer launched!'))
                        .catch(() => alert('Launch failed'));
                }
                </script>
                <script>
                    function showMemoryAlgo() {
                        const selected = document.getElementById('memory-algo-select').value;
                        const ids = ['firstfit', 'bestfit', 'worstfit', 'segmentation', 'paging'];

                        ids.forEach(id => {
                        const section = document.getElementById(id);
                        if (section) {
                            section.style.display = (id == selected) ? 'block' : 'none';
                        }
                        });
                    }
                </script>
            <!-- Algorithm Cards Style -->
            <style>
                .memory-algo-card {
                    display: none;
                    background: #fefefe;
                    border-left: 6px solid #2980b9;
                    padding: 24px;
                    border-radius: 12px;
                    margin-top: 20px;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.05);
                }

                .memory-algo-card h3 {
                    margin-top: 0;
                    color: #21618c;
                    font-size: 22px;
                }

                .memory-algo-card ul {
                    padding-left: 18px;
                }

                pre {
                    background-color: #f4f6f7;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 14px;
                    overflow-x: auto;
                }

                code {
                    font-family: 'Courier New', monospace;
                    color: #1B4F72;
                }
            </style>

            <!-- First Fit -->
            <div class="memory-algo-card" id="firstfit" style="display: block;">
                <h3>First Fit</h3>
                <p>Allocates the first memory block that is large enough for the process.</p>
                <ul>
                    <li><strong>Good for:</strong> Fast allocation</li>
                    <li><strong>Bad for:</strong> External fragmentation</li>
                </ul>
                <p><strong>Example:</strong> Blocks = [100, 500, 200], Process = 120 → allocates in 500</p>
                <h4>Python Example</h4>
                <pre><code>def first_fit(blocks, processes):
            allocation = [-1] * len(processes)
            for i, p in enumerate(processes):
                for j, b in enumerate(blocks):
                    if b >= p:
                        allocation[i] = j
                        blocks[j] -= p
                        break
            return allocation</code></pre>
            </div>

            <!-- Best Fit -->
            <div class="memory-algo-card" id="bestfit">
                <h3>Best Fit</h3>
                <p>Allocates the smallest block that is big enough for the process, minimizing wasted space.</p>
                <ul>
                    <li><strong>Good for:</strong> Reducing memory waste</li>
                    <li><strong>Bad for:</strong> Slower allocation time</li>
                </ul>
                <p><strong>Example:</strong> Blocks = [100, 200, 500], Process = 120 → allocates in 200</p>
                <h4>Python Example</h4>
                <pre><code>def best_fit(blocks, processes):
            allocation = [-1] * len(processes)
            for i, p in enumerate(processes):
                best_idx = -1
                for j, b in enumerate(blocks):
                    if b >= p and (best_idx == -1 or blocks[j] < blocks[best_idx]):
                        best_idx = j
                if best_idx != -1:
                    allocation[i] = best_idx
                    blocks[best_idx] -= p
            return allocation</code></pre>
            </div>

            <!-- Worst Fit -->
            <div class="memory-algo-card" id="worstfit">
                <h3>Worst Fit</h3>
                <p>Allocates the largest available memory block to reduce chances of small leftover memory.</p>
                <ul>
                    <li><strong>Good for:</strong> Avoiding fragmentation at the cost of space</li>
                    <li><strong>Bad for:</strong> Inefficient use of memory</li>
                </ul>
                <p><strong>Example:</strong> Blocks = [100, 200, 600], Process = 120 → allocates in 600</p>
                <h4>Python Example</h4>
                <pre><code>def worst_fit(blocks, processes):
            allocation = [-1] * len(processes)
            for i, p in enumerate(processes):
                worst_idx = -1
                for j, b in enumerate(blocks):
                    if b >= p and (worst_idx == -1 or blocks[j] > blocks[worst_idx]):
                        worst_idx = j
                if worst_idx != -1:
                    allocation[i] = worst_idx
                    blocks[worst_idx] -= p
            return allocation</code></pre>
            </div>

            <!-- Segmentation -->
            <div class="memory-algo-card" id="segmentation">
                <h3>Segmentation</h3>
                <p>Memory is divided into segments of variable size like code, stack, and data. Each segment has its own base and limit.</p>
                <ul>
                    <li><strong>Good for:</strong> Modular programming and protection</li>
                    <li><strong>Bad for:</strong> External fragmentation</li>
                </ul>
                <h4>Concept:</h4>
                <pre><code>segments = {
            "code": 1000,
            "stack": 500,
            "heap": 700
        }
        # Access using: physical_address = base + offset</code></pre>
            </div>

            <!-- Paging -->
            <div class="memory-algo-card" id="paging">
                <h3>Paging</h3>
                <p>Divides both memory and processes into fixed-size pages and frames. Eliminates external fragmentation.</p>
                <ul>
                    <li><strong>Good for:</strong> Efficient and uniform allocation</li>
                    <li><strong>Bad for:</strong> Internal fragmentation</li>
                </ul>
                <h4>Concept:</h4>
                <pre><code>frame_size = 100
        process = 350  # Requires 4 pages
        # Page table maps logical → physical frames</code></pre>
            </div>
        </section>
<!-- Memory Management Section -->


<!-- Memory Management Section -->

        <!-- Disk Scheduling Section -->

        <section id="disk-section" style="font-family: 'Inter', sans-serif;">
            <h2 style="font-size: 28px; color: #154360;">Disk Scheduling Algorithm Visualizer</h2>
            <p style="color: #333;">Learn how disk scheduling algorithms work with clear explanations, real algorithm logic, and interactive visualization triggers.</p>


            <div class="algorithm-controls" style="margin: 20px 0;">
                <select id="disk-algo-select" onchange="showDiskAlgo()" style="padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #aaa;">
                    <option value="fcfs_disk">FCFS (First-Come, First-Served)</option>
                    <option value="sstf">SSTF (Shortest Seek Time First)</option>
                    <option value="scan">SCAN</option>
                    <option value="cscan">C-SCAN</option>
                    <option value="look">LOOK</option>
                    <option value="clook">C-LOOK</option>
                </select>
                
                <button onclick="launchDiskScheduling()">Launch Visualizer</button>

                <script>
                function launchDiskScheduling() {
                    fetch('/disk_scheduling')
                        .then(() => alert('Visualizer launched!'))
                        .catch(() => alert('Launch failed'));
                }
                </script>

  
                <script>
                function showDiskAlgo() {
                    const selected = document.getElementById('disk-algo-select').value;
                    const ids = ['fcfs_disk', 'sstf', 'scan', 'cscan', 'look', 'clook'];

                    // If selected algo is not fcfs, clear fcfs div
                    if (selected !== 'fcfs_disk') {
                        const fcfsDiv = document.getElementById('fcfs_disk');
                        if (fcfsDiv) fcfsDiv.innerHTML = '';
                    }

                    ids.forEach(id => {
                        const section = document.getElementById(id);
                        if (section) {
                            section.style.display = (id === selected) ? 'block' : 'none';
                        }
                    });
                }

                // Show FCFS by default
                document.addEventListener("DOMContentLoaded", () => {
                    document.getElementById('fcfs_disk').style.display = 'block';
                });

                </script>

            <!-- Reusable Card Template -->
            <style>
                .disk-algo-card {
                    display: none;
                    background: #f4f9fd;
                    border-left: 6px solid #3498db;
                    padding: 24px;
                    border-radius: 12px;
                    margin-top: 20px;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.05);
                }

                .disk-algo-card h3 {
                    margin-top: 0;
                    color: #21618C;
                    font-size: 22px;
                }

                .disk-algo-card ul {
                    padding-left: 18px;
                }

                .btn-launch {
                    margin-left: 12px;
                    padding: 10px 16px;
                    background-color: #2E86C1;
                    color: white;
                    font-weight: bold;
                    border-radius: 6px;
                    border: none;
                    cursor: pointer;
                }

                pre {
                    background-color: #eaf3fb;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 14px;
                    overflow-x: auto;
                }

                code {
                    font-family: 'Courier New', monospace;
                    color: #1B4F72;
                }

            </style>

            <!-- FCFS -->
            <!-- <div class="disk-algo-card" id="fcfs" style="display: block;" > -->
            <div class="disk-algo-card" id="fcfs_disk"  >
                <h3>FCFS (First-Come, First-Served)</h3>
                <p>FCFS services disk requests in the exact order they arrive, without reordering. Its simple and fair but can be inefficient in terms of head movement.</p>
                <ul>
                    <li><strong>Good for:</strong> Simple systems, fair access</li>
                    <li><strong>Bad for:</strong> Systems needing optimization of seek time</li>
                </ul>
                <p><strong>Example:</strong> For requests at <code>[98, 183, 37, 122, 14]</code> and initial head at <code>53</code>, FCFS services them in the same order.</p>
                <h4>Algorithm (Python)</h4>
                <pre><code>def fcfs(requests, head):
            seek_sequence = []
            total_seek = 0
            for track in requests:
                seek_sequence.append(track)
                total_seek += abs(head - track)
                head = track
            return seek_sequence, total_seek</code></pre>
            </div>

            <!-- SSTF -->
            <div class="disk-algo-card" id="sstf">
                <h3>SSTF (Shortest Seek Time First)</h3>
                <p>SSTF chooses the request closest to the current head position, minimizing seek time at each step. This often lowers average seek time but may cause starvation.</p>
                <ul>
                    <li><strong>Good for:</strong> Minimizing head movement</li>
                    <li><strong>Bad for:</strong> Fairness, starvation risk</li>
                </ul>
                <p><strong>Example:</strong> From head 53, if requests are [14, 37, 65, 67], SSTF chooses 65 first.</p>
                <h4>Algorithm (Python)</h4>
                <pre><code>def sstf(requests, head):
            requests = requests.copy()
            seek_sequence = []
            total_seek = 0
            while requests:
                closest = min(requests, key=lambda x: abs(x - head))
                total_seek += abs(closest - head)
                seek_sequence.append(closest)
                head = closest
                requests.remove(closest)
            return seek_sequence, total_seek</code></pre>
            </div>

            <!-- SCAN -->
            <div class="disk-algo-card" id="scan">
                <h3>SCAN (Elevator Algorithm)</h3>
                <p>The head moves toward one end, servicing all requests in its path, then reverses and services the remaining in the other direction.</p>
                <ul>
                    <li><strong>Good for:</strong> Balanced performance</li>
                    <li><strong>Bad for:</strong> Uneven request arrival</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code>def scan(requests, head, direction, disk_size):
            requests.sort()
            left = [r for r in requests if r < head]
            right = [r for r in requests if r >= head]
            seek_sequence = []
            if direction == "left":
                for r in reversed(left): seek_sequence.append(r)
                for r in right: seek_sequence.append(r)
            else:
                for r in right: seek_sequence.append(r)
                for r in reversed(left): seek_sequence.append(r)
            return seek_sequence</code></pre>
            </div>

            <!-- C-SCAN -->
            <div class="disk-algo-card" id="cscan">
                <h3>C-SCAN (Circular SCAN)</h3>
                <p>C-SCAN moves in one direction only. After reaching the end, the head jumps to the beginning and continues scanning.</p>
                <ul>
                    <li><strong>Good for:</strong> Uniform wait time</li>
                    <li><strong>Bad for:</strong> Wasted full jump movement</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code>def cscan(requests, head, disk_size):
            requests.sort()
            right = [r for r in requests if r >= head]
            left = [r for r in requests if r < head]
            seek_sequence = right + left
            return seek_sequence</code></pre>
            </div>

            <!-- LOOK -->
            <div class="disk-algo-card" id="look">
                <h3>LOOK</h3>
                <p>LOOK is like SCAN, but the head only goes as far as the furthest request and then reverses.</p>
                <ul>
                    <li><strong>Good for:</strong> Reducing unnecessary movement</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code>def look(requests, head, direction):
            requests.sort()
            left = [r for r in requests if r < head]
            right = [r for r in requests if r >= head]
            seek_sequence = []
            if direction == "left":
                for r in reversed(left): seek_sequence.append(r)
                for r in right: seek_sequence.append(r)
            else:
                for r in right: seek_sequence.append(r)
                for r in reversed(left): seek_sequence.append(r)
            return seek_sequence</code></pre>
            </div>

            <!-- C-LOOK -->
            <div class="disk-algo-card" id="clook">
                <h3>C-LOOK (Circular LOOK)</h3>
                <p>C-LOOK only goes as far as the last request, then jumps to the lowest pending one. It is more efficient than C-SCAN.</p>
                <ul>
                    <li><strong>Good for:</strong> Balanced performance and efficiency</li>
                </ul>
                <h4>Algorithm (Python)</h4>
                <pre><code>def clook(requests, head):
            requests.sort()
            right = [r for r in requests if r >= head]
            left = [r for r in requests if r < head]
            seek_sequence = right + left
            return seek_sequence</code></pre>
            </div>

 </section>

<!-- Disk Scheduling Section -->
 
        <!-- Page Replacement Section -->
         
        <section id="page-section" style="font-family: 'Inter', sans-serif;">
            <h2 style="font-size: 28px; color: #6C3483;">Page Replacement Algorithms</h2>
            <p style="color: #333;">Page replacement algorithms determine which memory pages to remove when a new page needs to be loaded into limited available frames.</p>

            <div class="algorithm-controls" style="margin: 20px 0;">
                <select id="page-algo-select" onchange="showPageAlgo()" style="padding: 10px; font-size: 16px; border-radius: 8px; border: 1px solid #aaa;">
                    <option value="fifo">FIFO</option>
                    <option value="lru">LRU</option>
                    <option value="lfu">LFU</option>
                    <option value="mfu">MFU</option>
                    <option value="optimal">Optimal</option>
                </select>

                <button onclick="launchPageReplacement()">Launch Visualizer</button>

                <script>
                function launchPageReplacement() {
                    fetch('/page_Replacement')
                        .then(() => alert('Visualizer launched!'))
                        .catch(() => alert('Launch failed'));
                }
                </script>
            <script>
                    function showPageAlgo() {
                        const selected = document.getElementById('page-algo-select').value;
                        const ids = ['fifo', 'lru', 'lfu', 'mfu', 'optimal'];

                        ids.forEach(id => {
                        const section = document.getElementById(id);
                        if (section) {
                            section.style.display = (id == selected) ? 'block' : 'none';
                        }
                        });
                    }
            </script>
            <style>
                .page-algo-card {
                    display: none;
                    background: #fefefe;
                    border-left: 6px solid #884EA0;
                    padding: 24px;
                    border-radius: 12px;
                    margin-top: 20px;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.05);
                }

                .page-algo-card h3 {
                    margin-top: 0;
                    color: #6C3483;
                    font-size: 22px;
                }

                .page-algo-card ul {
                    padding-left: 18px;
                }

                pre {
                    background-color: #f4f6f7;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 14px;
                    overflow-x: auto;
                }

                code {
                    font-family: 'Courier New', monospace;
                    color: #4A235A;
                }
            </style>

            <!-- FIFO -->
            <div class="page-algo-card" id="fifo" style="display: block;">
                <h3>FIFO (First-In, First-Out)</h3>
                <p>Replaces the oldest loaded page in memory.</p>
                <ul>
                    <li>Simple and easy to implement</li>
                    <li>Doesn't consider page usage frequency</li>
                </ul>
                <h4>Python Example</h4>
                <pre><code>from collections import deque

        def fifo(pages, frames):
            queue = deque()
            page_faults = 0
            for page in pages:
                if page not in queue:
                    if len(queue) == frames:
                        queue.popleft()
                    queue.append(page)
                    page_faults += 1
            return page_faults</code></pre>
            </div>

            <!-- LRU -->
            <div class="page-algo-card" id="lru">
                <h3>LRU (Least Recently Used)</h3>
                <p>Replaces the page that hasn’t been used for the longest time.</p>
                <ul>
                    <li>Based on access history</li>
                    <li>More accurate than FIFO, but costlier</li>
                </ul>
                <h4>Python Example</h4>
                <pre><code>def lru(pages, frames):
            memory = []
            page_faults = 0
            for i, page in enumerate(pages):
                if page not in memory:
                    if len(memory) == frames:
                        lru_index = min(memory, key=lambda p: pages[:i][::-1].index(p))
                        memory.remove(lru_index)
                    memory.append(page)
                    page_faults += 1
            return page_faults</code></pre>
            </div>

            <!-- LFU -->
            <div class="page-algo-card" id="lfu">
                <h3>LFU (Least Frequently Used)</h3>
                <p>Replaces the page with the lowest frequency of use.</p>
                <ul>
                    <li>Tracks how often a page is accessed</li>
                    <li>Can suffer from frequency aging issues</li>
                </ul>
                <h4>Python Example</h4>
                <pre><code>from collections import Counter

        def lfu(pages, frames):
            memory = []
            count = Counter()
            page_faults = 0
            for page in pages:
                count[page] += 1
                if page not in memory:
                    if len(memory) == frames:
                        victim = min(memory, key=lambda p: count[p])
                        memory.remove(victim)
                    memory.append(page)
                    page_faults += 1
            return page_faults</code></pre>
            </div>

            <!-- MFU -->
            <div class="page-algo-card" id="mfu">
                <h3>MFU (Most Frequently Used)</h3>
                <p>Replaces the most frequently used page, assuming it's less likely to be used again soon.</p>
                <ul>
                    <li>Opposite of LFU</li>
                    <li>Based on the idea of frequency saturation</li>
                </ul>
                <h4>Python Example</h4>
                <pre><code>from collections import Counter

        def mfu(pages, frames):
            memory = []
            count = Counter()
            page_faults = 0
            for page in pages:
                count[page] += 1
                if page not in memory:
                    if len(memory) == frames:
                        victim = max(memory, key=lambda p: count[p])
                        memory.remove(victim)
                    memory.append(page)
                    page_faults += 1
            return page_faults</code></pre>
            </div>

            <!-- Optimal -->
            <div class="page-algo-card" id="optimal">
                <h3>Optimal</h3>
                <p>Replaces the page that won’t be used for the longest time in the future.</p>
                <ul>
                    <li>Theoretically best (requires future knowledge)</li>
                    <li>Used as a benchmark</li>
                </ul>
                <h4>Python Example</h4>
                <pre><code>def optimal(pages, frames):
            memory = []
            page_faults = 0
            for i, page in enumerate(pages):
                if page not in memory:
                    if len(memory) == frames:
                        future = pages[i+1:]
                        victim = max(memory, key=lambda p: future.index(p) if p in future else float('inf'))
                        memory.remove(victim)
                    memory.append(page)
                    page_faults += 1
            return page_faults</code></pre>
            </div>
        </section>

<!-- Page Replacement Section -->
        <section id="os-section" style="font-family: 'Inter', sans-serif;" >
        <!-- OS Concepts Section -->
        <h2>OS Concepts Visualization</h2>
        <p>Explore fundamental operating system concepts through interactive visualizations and explanations.</p>


            <style>
                .os-concept-card {
                    background: #fefefe;
                    border-left: 6px solid #884EA0;
                    padding: 24px;
                    border-radius: 12px;
                    margin-top: 20px;
                    box-shadow: 0 3px 8px rgba(0,0,0,0.05);
                }

                .os-concept-card h3 {
                    margin-top: 0;
                    color: #6C3483;
                    font-size: 22px;
                }

                .os-concept-card ul {
                    padding-left: 18px;
                }

                pre {
                    background-color: #f4f6f7;
                    padding: 12px;
                    border-radius: 8px;
                    font-size: 14px;
                    overflow-x: auto;
                }

                .os-concept-card h3 {
                    color: var(--primary-color);
                    margin-bottom: 1rem;
                }

                .os-concept-card p {
                    margin-bottom: 1rem;
                }

                .os-concept-img {
                    width: 100%;
                    max-height: 300px;
                    object-fit: contain;
                    margin: 1rem 0;
                    border-radius: 4px;
                }

                .explanation-box {
                    background-color: #f8f9fa;
                    border-left: 4px solid var(--primary-color);
                    padding: 1rem;
                    margin-top: 1rem;
                    border-radius: 0 4px 4px 0;
                }

                
            </style>

            <div class="os-concept-card" id="process-states-card">
                <h3>Process States</h3>
                <p>A process changes its state as it executes. The main process states are:</p>
                <ul>
                    <li><strong>New:</strong> The process is being created</li>
                    <li><strong>Ready:</strong> The process is waiting to be assigned to a processor</li>
                    <li><strong>Running:</strong> Instructions are being executed</li>
                    <li><strong>Waiting:</strong> The process is waiting for some event to occur</li>
                    <li><strong>Terminated:</strong> The process has finished execution</li>
                </ul>
                <div class="explanation-box">
                    <h4>Explanation</h4>
                    <p>Process state transitions occur due to various events:</p>
                    <ul>
                        <li><strong>Admit:</strong> New → Ready (when OS admits the process)</li>
                        <li><strong>Dispatch:</strong> Ready → Running (when scheduler selects the process)</li>
                        <li><strong>Timeout:</strong> Running → Ready (when time quantum expires)</li>
                        <li><strong>Event Wait:</strong> Running → Waiting (when process needs to wait for I/O)</li>
                        <li><strong>Event Occurs:</strong> Waiting → Ready (when I/O completes)</li>
                        <li><strong>Exit:</strong> Running → Terminated (when process completes)</li>
                    </ul>
                </div>
            </div>

            <div class="os-concept-card" id="process-threads-card" >
                <h3>Process vs Threads</h3>
                <p>Processes and threads are both execution sequences, but they differ in several ways:</p>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Process</th>
                            <th>Thread</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Definition</td>
                            <td>An executing program with its own address space</td>
                            <td>A lightweight process within a process</td>
                        </tr>
                        <tr>
                            <td>Memory</td>
                            <td>Separate memory space</td>
                            <td>Shares memory with other threads</td>
                        </tr>
                        <tr>
                            <td>Creation</td>
                            <td>Slower due to memory allocation</td>
                            <td>Faster as it shares memory</td>
                        </tr>
                        <tr>
                            <td>Communication</td>
                            <td>IPC mechanisms required</td>
                            <td>Direct communication through shared memory</td>
                        </tr>
                        <tr>
                            <td>Context Switching</td>
                            <td>More expensive</td>
                            <td>Less expensive</td>
                        </tr>
                    </tbody>
                </table>
                <div class="explanation-box">
                    <h4>Explanation</h4>
                    <p>Threads are often called lightweight processes because they share the same address space and resources of the process that created them. This makes communication between threads simpler and more efficient than between processes. However, this shared access also requires careful synchronization to avoid race conditions and other concurrency issues.</p>
                </div>
            </div>

            <div class="os-concept-card" id="scheduling-card" >
                <h3>Scheduling Concepts</h3>
                <p>CPU scheduling is the basis of multiprogrammed operating systems. The scheduler selects from among the processes in memory that are ready to execute and allocates the CPU to one of them.</p>
                
                <h4>Scheduling Queues</h4>
                <ul>
                    <li><strong>Job Queue:</strong> All processes in the system</li>
                    <li><strong>Ready Queue:</strong> Processes residing in main memory, ready and waiting to execute</li>
                    <li><strong>Device Queues:</strong> Processes waiting for an I/O device</li>
                </ul>
                
                <h4>Scheduling Criteria</h4>
                <ul>
                    <li><strong>CPU Utilization:</strong> Keep the CPU as busy as possible</li>
                    <li><strong>Throughput:</strong> Number of processes completed per time unit</li>
                    <li><strong>Turnaround Time:</strong> Time from submission to completion</li>
                    <li><strong>Waiting Time:</strong> Time spent waiting in ready queue</li>
                    <li><strong>Response Time:</strong> Time from submission until first response</li>
                </ul>
                
                
                <div class="explanation-box">
                    <h4>Explanation</h4>
                    <p>Scheduling can be preemptive or non-preemptive:</p>
                    <ul>
                        <li><strong>Preemptive:</strong> OS can force a process to relinquish the CPU (e.g., Round Robin)</li>
                        <li><strong>Non-preemptive:</strong> Process keeps CPU until it releases it (e.g., FCFS, SJF)</li>
                    </ul>
                    <p>The choice of scheduling algorithm depends on the system goals (e.g., batch vs interactive systems).</p>
                </div>
            </div>

            <div class="os-concept-card" id="memory-hierarchy-card">
                <h3>Memory Hierarchy</h3>
                <p>Computer systems organize memory in a hierarchy to optimize performance and cost:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Level</th>
                            <th>Type</th>
                            <th>Speed</th>
                            <th>Size</th>
                            <th>Cost</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Registers</td>
                            <td>Fastest</td>
                            <td>Smallest</td>
                            <td>Highest</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>Cache (L1, L2, L3)</td>
                            <td>Very Fast</td>
                            <td>Small</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Main Memory (RAM)</td>
                            <td>Fast</td>
                            <td>Medium</td>
                            <td>Moderate</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Secondary Storage (SSD/HDD)</td>
                            <td>Slow</td>
                            <td>Large</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Tertiary Storage (Tape, Optical)</td>
                            <td>Slowest</td>
                            <td>Largest</td>
                            <td>Lowest</td>
                        </tr>
                    </tbody>
                </table>
                
                
                <div class="explanation-box">
                    <h4>Explanation</h4>
                    <p>The memory hierarchy exists because:</p>
                    <ul>
                        <li>Faster memory is more expensive per byte</li>
                        <li>Programs tend to access a small portion of their address space at any time (locality principle)</li>
                    </ul>
                    <p>Operating systems manage this hierarchy through techniques like caching, virtual memory, and paging to give the illusion of a large, fast memory space.</p>
                </div>
            </div>

            <div class="os-concept-card" id="deadlocks-card" >
                <h3>Deadlocks</h3>
                <p>A deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process.</p>
                
                <h4>Necessary Conditions for Deadlock</h4>
                <ol>
                    <li><strong>Mutual Exclusion:</strong> At least one resource must be held in a non-sharable mode</li>
                    <li><strong>Hold and Wait:</strong> A process holding at least one resource is waiting to acquire additional resources</li>
                    <li><strong>No Preemption:</strong> Resources cannot be forcibly taken from processes</li>
                    <li><strong>Circular Wait:</strong> A set of processes {P1, P2, ..., Pn} exists where P1 is waiting for P2, P2 for P3, ..., Pn for P1</li>
                </ol>
                
                
                <div class="explanation-box">
                    <h4>Deadlock Handling Methods</h4>
                    <ul>
                        <li><strong>Prevention:</strong> Ensure at least one of the four conditions never holds</li>
                        <li><strong>Avoidance:</strong> Use algorithms like Banker's algorithm to avoid unsafe states</li>
                        <li><strong>Detection & Recovery:</strong> Allow deadlocks to occur, then detect and recover</li>
                        <li><strong>Ignore:</strong> Pretend deadlocks never occur (used by many OSes)</li>
                    </ul>
                </div>
            </div>


        </section>
    </main>

    <footer>
        <div class="container">
            <p>OS Algorithm Visualizer  | Designed for Educational Purposes</p>
        </div>
    </footer>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Navigation between sections
            const navLinks = document.querySelectorAll('nav a');
            const sections = document.querySelectorAll('section');
            
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all nav links
                    navLinks.forEach(navLink => navLink.classList.remove('active'));
                    
                    // Add active class to clicked nav link
                    this.classList.add('active');
                    
                    // Hide all sections
                    sections.forEach(section => section.classList.remove('active-section'));
                    
                    // Show the selected section
                    const sectionId = this.getAttribute('data-section') + '-section';
                    document.getElementById(sectionId).classList.add('active-section');
                });
            });
            
            // Card click navigation
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                card.addEventListener('click', function() {
                    const section = this.getAttribute('data-section');
                    const navLink = document.querySelector(`nav a[data-section="${section}"]`);
                    navLink.click();
                });
            });
            
        })
            
    </script>

</body>
</html>